<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Private Information Retrieval: Query Without Revealing What You're Querying | Rohan Vinaik</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&display=swap" rel="stylesheet">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <style>
    :root {
      --bg: #1a1a1a;
      --text: #e0e0e0;
      --text-secondary: #808080;
      --accent: #00ffff;
      --border: rgba(255, 255, 255, 0.1);
      --code-bg: #222222;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'JetBrains Mono', monospace;
      background: var(--bg);
      color: var(--text);
      line-height: 1.6;
      padding: 20px;
      max-width: 900px;
      margin: 0 auto;
    }
    h1 {
      color: var(--accent);
      font-size: 1.5rem;
      margin-bottom: 8px;
      letter-spacing: 0.02em;
    }
    h2 {
      color: var(--accent);
      font-size: 1.1rem;
      margin-top: 32px;
      margin-bottom: 16px;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--border);
    }
    h3 {
      color: var(--accent);
      font-size: 0.95rem;
      margin-top: 24px;
      margin-bottom: 12px;
    }
    h4 {
      color: var(--text);
      font-size: 0.85rem;
      margin-top: 20px;
      margin-bottom: 10px;
      font-weight: 600;
    }
    p { margin-bottom: 16px; font-size: 0.85rem; }
    a {
      color: var(--accent);
      text-decoration: none;
      border-bottom: 1px dotted var(--accent);
    }
    a:hover { border-bottom-style: solid; }
    .back-link {
      display: inline-block;
      margin-bottom: 24px;
      font-size: 0.85rem;
    }
    .paper-meta {
      color: var(--text-secondary);
      font-size: 0.75rem;
      margin-bottom: 24px;
    }
    .abstract {
      background: var(--code-bg);
      padding: 20px;
      border-left: 3px solid var(--accent);
      margin-bottom: 32px;
      font-size: 0.85rem;
    }
    .tags {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 32px;
    }
    .tag {
      background: var(--code-bg);
      padding: 4px 12px;
      border: 1px solid var(--border);
      font-size: 0.7rem;
      color: var(--accent);
      text-decoration: none;
      border-bottom: none;
    }
    .tag:hover {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
    }
    .quick-nav {
      background: var(--code-bg);
      padding: 16px;
      margin-bottom: 32px;
      border: 1px solid var(--border);
    }
    .quick-nav h3 {
      margin-top: 0;
      font-size: 0.85rem;
    }
    .quick-nav ul {
      list-style: none;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 8px;
      margin-top: 12px;
    }
    .quick-nav a {
      font-size: 0.75rem;
      border-bottom: none;
      padding: 4px 0;
      display: block;
    }
    .quick-nav a:hover { color: var(--bg); background: var(--accent); padding-left: 8px; }
    pre {
      background: var(--code-bg);
      padding: 16px;
      border: 1px solid var(--border);
      border-left: 3px solid var(--accent);
      overflow-x: auto;
      font-size: 0.75rem;
      margin: 16px 0;
      line-height: 1.4;
    }
    code {
      font-family: 'JetBrains Mono', monospace;
      background: var(--code-bg);
      padding: 2px 6px;
      border: 1px solid var(--border);
      font-size: 0.8em;
    }
    pre code {
      border: none;
      padding: 0;
    }
    ul, ol {
      margin-left: 24px;
      margin-bottom: 16px;
    }
    li {
      margin-bottom: 8px;
      font-size: 0.85rem;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
      font-size: 0.75rem;
    }
    th, td {
      border: 1px solid var(--border);
      padding: 12px;
      text-align: left;
    }
    th {
      background: var(--code-bg);
      color: var(--accent);
      font-weight: 600;
    }
    .references {
      font-size: 0.75rem;
      margin-top: 32px;
    }
    .references ol {
      padding-left: 20px;
    }
    .references li {
      margin-bottom: 12px;
      line-height: 1.5;
    }
    @media (max-width: 768px) {
      body { padding: 12px; }
      h1 { font-size: 1.2rem; }
      h2 { font-size: 1rem; }
    }
  </style>
</head>
<body>

<a href="../index.html#reference" class="back-link">‚Üê Back to Reference</a>

<h1>Private Information Retrieval: Query Without Revealing What You're Querying</h1>
<div class="paper-meta">January 2025 ¬∑ TECHNICAL REFERENCE</div>

<div class="tags">
  <a href="../index.html?filter=PRIVATE-INFORMATION-RETRIEVAL" class="tag">[PRIVATE-INFORMATION-RETRIEVAL]</a>
  <a href="../index.html?filter=CRYPTOGRAPHY" class="tag">[CRYPTOGRAPHY]</a>
  <a href="../index.html?filter=PRIVACY-PRESERVING" class="tag">[PRIVACY-PRESERVING]</a>
  <a href="../index.html?filter=HOMOMORPHIC-ENCRYPTION" class="tag">[HOMOMORPHIC-ENCRYPTION]</a>
  <a href="../index.html?filter=INFORMATION-THEORETIC" class="tag">[INFORMATION-THEORETIC]</a>
  <a href="../index.html?filter=GENOMICS" class="tag">[GENOMICS]</a>
  <a href="../index.html?filter=SECURE-COMPUTATION" class="tag">[SECURE-COMPUTATION]</a>
  <a href="../index.html?filter=DATABASE-PRIVACY" class="tag">[DATABASE-PRIVACY]</a>
  <a href="../index.html?filter=COMMUNICATION-COMPLEXITY" class="tag">[COMMUNICATION-COMPLEXITY]</a>
  <a href="../index.html?filter=LATTICE-CRYPTOGRAPHY" class="tag">[LATTICE-CRYPTOGRAPHY]</a>
</div>

<div class="abstract">
  <strong>Abstract:</strong> Private Information Retrieval (PIR) enables a client to query a database without revealing which item was requested to the server. The server learns absolutely nothing about the query (zero bits of information in information-theoretic PIR), while the client retrieves the desired item correctly. This cryptographic primitive addresses fundamental privacy concerns in database access, genomic queries, private search, certificate transparency, and secure computation. This document covers core principles, information-theoretic foundations, computational approaches, mathematical constructions, PIR schemes (multi-server IT-PIR, lattice-based computational PIR, homomorphic encryption PIR), security analysis, implementation techniques, communication complexity, and applications in privacy-sensitive domains.
</div>

<div class="quick-nav">
  <h3>Quick Navigation</h3>
  <ul>
    <li><a href="#core-principles">1. Core Principles</a></li>
    <li><a href="#mathematical-foundations">2. Mathematical Foundations</a></li>
    <li><a href="#pir-schemes">3. PIR Schemes</a></li>
    <li><a href="#security-analysis">4. Security Analysis</a></li>
    <li><a href="#implementation">5. Implementation</a></li>
    <li><a href="#applications">6. Applications</a></li>
    <li><a href="#references">References</a></li>
  </ul>
</div>

<h2 id="core-principles">1. Core Principles</h2>

<h3>1.1 The PIR Problem</h3>

<p><strong>Problem Statement:</strong> A client wants to retrieve database element x<sub>i</sub> at index i from a server without the server learning which index was accessed.</p>

<pre><code>Database: D = (x‚ÇÅ, x‚ÇÇ, ..., x‚Çô) stored on server(s)
Client input: index i ‚àà [1, n]
Client goal: retrieve x·µ¢
Privacy requirement: server learns nothing about i</code></pre>

<p><strong>Trivial Solution:</strong> Download the entire database.</p>

<pre><code>Communication: O(n¬∑|x|) where |x| is element size
Privacy: Perfect - server sees nothing about query
Problem: Impractical for large databases (e.g., genomic databases, certificate lists)</code></pre>

<p><strong>Non-Trivial Goal:</strong> Achieve sublinear communication complexity while maintaining privacy.</p>

<pre><code>Target: O(n^c) communication where c < 1
Examples:
  - O(‚àön) for two-server IT-PIR
  - O(n^(1/k)) for k-server IT-PIR
  - O(log¬≤ n) for some computational PIR schemes</code></pre>

<h3>1.2 Security Definitions</h3>

<h4>Information-Theoretic Privacy</h4>

<p><strong>Definition:</strong> A computationally unbounded server learns zero bits of information about the query index.</p>

<pre><code>Formal Property:
For any two indices i, j ‚àà [1, n]:
  P(ServerView | i) = P(ServerView | j)

Shannon Entropy Condition:
  H(i | ServerView) = H(i)

Mutual Information:
  I(i ; ServerView) = 0</code></pre>

<p>The server's view of the protocol execution is statistically independent of the query index. No amount of computational power can extract information about i from what the server observes.</p>

<h4>Computational Privacy</h4>

<p><strong>Definition:</strong> A computationally bounded server (probabilistic polynomial-time adversary) cannot distinguish between queries for different indices.</p>

<pre><code>Formal Property:
For any PPT adversary A and indices i, j ‚àà [1, n]:
  |P(A(ServerView_i) = 1) - P(A(ServerView_j) = 1)| ‚â§ negl(Œª)

where Œª is security parameter and negl(Œª) = 2^(-œâ(log Œª))</code></pre>

<p>Privacy relies on computational hardness assumptions (e.g., LWE, DDH, RSA). If the assumption breaks, privacy may be compromised.</p>

<h4>Computational Assumptions Used</h4>

<table>
  <thead>
    <tr>
      <th>Assumption</th>
      <th>Problem</th>
      <th>PIR Schemes</th>
      <th>Post-Quantum</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>LWE</td>
      <td>Learning With Errors</td>
      <td>Lattice-based PIR</td>
      <td>‚úÖ Yes</td>
    </tr>
    <tr>
      <td>DDH</td>
      <td>Decisional Diffie-Hellman</td>
      <td>ElGamal-based PIR</td>
      <td>‚ùå No</td>
    </tr>
    <tr>
      <td>DCR</td>
      <td>Decisional Composite Residuosity</td>
      <td>Paillier PIR</td>
      <td>‚ùå No</td>
    </tr>
    <tr>
      <td>RLWE</td>
      <td>Ring Learning With Errors</td>
      <td>SEAL PIR, OnionPIR</td>
      <td>‚úÖ Yes</td>
    </tr>
  </tbody>
</table>

<h3>1.3 Correctness</h3>

<p><strong>Requirement:</strong> The client always retrieves the correct element from the database.</p>

<pre><code>Correctness Property:
For all databases D and indices i:
  P(PIR(D, i) = x·µ¢) = 1 (perfect correctness)
  or
  P(PIR(D, i) = x·µ¢) ‚â• 1 - negl(Œª) (computational correctness)</code></pre>

<h3>1.4 Single-Server vs Multi-Server PIR</h3>

<p><strong>Single-Server Computational PIR:</strong></p>
<ul>
  <li>One database copy</li>
  <li>Relies on cryptographic assumptions</li>
  <li>Higher server computation cost</li>
  <li>More practical deployment</li>
</ul>

<p><strong>Multi-Server Information-Theoretic PIR:</strong></p>
<ul>
  <li>Database replicated across k ‚â• 2 servers</li>
  <li>Perfect privacy (no assumptions)</li>
  <li>Requires non-collusion assumption</li>
  <li>Lower server computation</li>
  <li>Better communication complexity</li>
</ul>

<h2 id="mathematical-foundations">2. Mathematical Foundations</h2>

<h3>2.1 Information-Theoretic PIR Foundations</h3>

<h4>Basic Two-Server Construction</h4>

<p><strong>Setting:</strong> Database D = (x‚ÇÅ, ..., x‚Çô) replicated on two non-colluding servers.</p>

<p><strong>Protocol:</strong></p>

<pre><code>Goal: Retrieve x·µ¢

Step 1: Query Generation
  Client generates random vector r = (r‚ÇÅ, ..., r‚Çô) ‚àà ùîΩ‚Çö‚Åø
  Client constructs query vector q where:
    q‚±º = r‚±º         if j ‚â† i
    q·µ¢ = r·µ¢ + 1     (single differing position)

Step 2: Query Distribution
  Send to Server 1: q = (q‚ÇÅ, ..., q‚Çô)
  Send to Server 2: r = (r‚ÇÅ, ..., r‚Çô)

Step 3: Server Computation
  Server 1 computes: a‚ÇÅ = Œ£‚±º‚Çå‚ÇÅ‚Åø q‚±º ¬∑ x‚±º = Œ£‚±º‚Çå‚ÇÅ‚Åø r‚±º ¬∑ x‚±º + x·µ¢
  Server 2 computes: a‚ÇÇ = Œ£‚±º‚Çå‚ÇÅ‚Åø r‚±º ¬∑ x‚±º

Step 4: Client Recovery
  Client computes: x·µ¢ = a‚ÇÅ - a‚ÇÇ</code></pre>

<p><strong>Privacy Analysis:</strong></p>

<pre><code>Server 1's View:
  Sees vector q = (r‚ÇÅ, ..., r·µ¢ + 1, ..., r‚Çô)
  Since r is uniformly random, q is uniformly random
  Zero information about i

Server 2's View:
  Sees vector r = (r‚ÇÅ, ..., r‚Çô)
  Uniformly random vector
  Zero information about i

Collusion:
  If servers compare: q - r = (0, ..., 1, ..., 0) reveals i
  Non-collusion is essential</code></pre>

<p><strong>Communication Complexity:</strong></p>

<pre><code>Query size per server: O(n ¬∑ log p) bits
Response size per server: O(log |x·µ¢|) bits
Total communication: O(n) bits

Not yet sublinear!</code></pre>

<h4>Recursive Construction for Sublinear Communication</h4>

<p><strong>Key Insight:</strong> Arrange database as multi-dimensional hypercube and query recursively.</p>

<p><strong>Two-Server Recursive PIR:</strong></p>

<pre><code>Database Structure:
  Arrange n elements as ‚àön √ó ‚àön matrix M
  Element at position (i‚ÇÅ, i‚ÇÇ): M[i‚ÇÅ][i‚ÇÇ] = x_{i‚ÇÅ¬∑‚àön + i‚ÇÇ}

Protocol:
  Round 1: Query column i‚ÇÇ
    - Use basic PIR to retrieve column i‚ÇÇ
    - Each server returns one value per row
    - Communication: O(‚àön) query + O(‚àön) response

  Round 2: Query element i‚ÇÅ from retrieved column
    - Apply basic PIR to the ‚àön-element column
    - Communication: O(‚àön) query + O(1) response

Total Communication: O(‚àön)</code></pre>

<p><strong>Generalization to k Servers:</strong></p>

<pre><code>Database Structure:
  Arrange as k-dimensional hypercube: n^(1/k) √ó ... √ó n^(1/k)

Communication Complexity:
  O(k ¬∑ n^(1/k)) total communication

Examples:
  k = 2: O(‚àön)
  k = 3: O(‚àõn)
  k = log n: O(log¬≤ n)

Trade-off: More servers ‚Üí better communication but stricter non-collusion</code></pre>

<h3>2.2 Computational PIR Foundations</h3>

<h4>Homomorphic Encryption Primer</h4>

<p><strong>Additively Homomorphic Encryption:</strong></p>

<pre><code>Properties:
  Enc(m‚ÇÅ) ‚äï Enc(m‚ÇÇ) = Enc(m‚ÇÅ + m‚ÇÇ)
  c ¬∑ Enc(m) = Enc(c ¬∑ m) for constant c

Examples:
  - Paillier: Enc(m‚ÇÅ) ¬∑ Enc(m‚ÇÇ) = Enc(m‚ÇÅ + m‚ÇÇ)
  - LWE: (Enc(m‚ÇÅ), Enc(m‚ÇÇ)) ‚Üí Enc(m‚ÇÅ + m‚ÇÇ)
  - ElGamal: Multiplicative but can encode additive structure</code></pre>

<h4>Basic Homomorphic PIR Construction</h4>

<pre><code>Setup Phase:
  Client generates key pair (pk, sk)
  Public key pk shared with server
  Secret key sk kept private

Query Construction:
  Create indicator vector: q = (q‚ÇÅ, ..., q‚Çô) where
    q‚±º = 0  if j ‚â† i
    q·µ¢ = 1

  Encrypt element-wise: Q = (Enc(q‚ÇÅ), ..., Enc(q‚Çô))

  Send encrypted query Q to server

Server Computation:
  Compute homomorphically:
    E_result = Œ£‚±º‚Çå‚ÇÅ‚Åø Enc(q‚±º) ‚äô x‚±º
             = Enc(Œ£‚±º‚Çå‚ÇÅ‚Åø q‚±º ¬∑ x‚±º)
             = Enc(x·µ¢)

  Return E_result to client

Client Recovery:
  Decrypt: x·µ¢ = Dec_sk(E_result)</code></pre>

<p><strong>Security:</strong> Based on semantic security of encryption scheme. Server sees only encrypted query which is computationally indistinguishable from encryption of any other query.</p>

<h3>2.3 Lattice-Based Constructions (LWE)</h3>

<h4>Learning With Errors (LWE)</h4>

<p><strong>Problem Definition:</strong></p>

<pre><code>Public: Matrix A ‚àà Z‚Çë‚ÅøÀ£·µê, vector b ‚àà Z‚Çë·µê
Secret: Vector s ‚àà Z‚Çë‚Åø such that b ‚âà A·µÄs + e
where e is small error vector

Hardness: Distinguish (A, b = A·µÄs + e) from (A, uniform)</code></pre>

<h4>LWE Encryption Scheme</h4>

<pre><code>Key Generation:
  Sample A ‚àà Z‚Çë‚ÅøÀ£·µê uniformly
  Sample secret s ‚àà Z‚Çë‚Åø
  Sample error e ‚àà Z‚Çë·µê from error distribution œá
  Compute b = A·µÄs + e
  pk = (A, b), sk = s

Encryption of message Œº ‚àà Z‚Çë:
  Sample r ‚àà {0,1}·µê
  u = Ar ‚àà Z‚Çë‚Åø
  v = b·µÄr + Œº¬∑‚åäq/2‚åã ‚àà Z‚Çë
  Ciphertext: (u, v)

Decryption:
  Compute v - s·µÄu = b·µÄr + Œº¬∑‚åäq/2‚åã - s·µÄAr
                  = (A·µÄs + e)·µÄr + Œº¬∑‚åäq/2‚åã - s·µÄAr
                  = e·µÄr + Œº¬∑‚åäq/2‚åã

  Round to recover Œº (if error e·µÄr is small)

Homomorphic Addition:
  (u‚ÇÅ, v‚ÇÅ) + (u‚ÇÇ, v‚ÇÇ) = (u‚ÇÅ + u‚ÇÇ, v‚ÇÅ + v‚ÇÇ)
  Decrypts to Œº‚ÇÅ + Œº‚ÇÇ (with slightly larger error)</code></pre>

<h4>LWE-Based PIR Protocol</h4>

<pre><code>Parameters:
  Database: n elements, each ‚Ñì bits
  Security: Œª bits
  Lattice dimension: n_LWE ‚âà O(Œª)
  Modulus: q ‚âà 2^(O(Œª))

Query Construction:
  Indicator vector: q = (0, ..., 1, ..., 0) position i
  Encrypt: Q = (LWE.Enc(q‚ÇÅ), ..., LWE.Enc(q‚Çô))
  Query size: O(n ¬∑ n_LWE ¬∑ log q) = O(n ¬∑ Œª¬≤) bits

Server Computation:
  For each bit position b ‚àà [1, ‚Ñì]:
    Compute homomorphically:
      c_b = Œ£‚±º‚Çå‚ÇÅ‚Åø Q[j] ¬∑ x_j[b]

  Response: (c‚ÇÅ, ..., c_‚Ñì)
  Response size: O(‚Ñì ¬∑ n_LWE ¬∑ log q) = O(‚Ñì ¬∑ Œª¬≤) bits

Optimization - Recursive Structure:
  Arrange as ‚àön √ó ‚àön matrix
  Query column: O(‚àön ¬∑ Œª¬≤) bits
  Response: O(‚àön ¬∑ ‚Ñì) bits
  Second round on column: O(‚àön ¬∑ Œª¬≤) bits
  Final response: O(‚Ñì ¬∑ Œª¬≤) bits

  Total: O(‚àön ¬∑ Œª¬≤ + ‚àön ¬∑ ‚Ñì) bits</code></pre>

<h3>2.4 Ring-LWE and Efficient PIR</h3>

<h4>Ring-LWE (RLWE)</h4>

<p><strong>Efficiency Gain:</strong> Operate over polynomial rings instead of vectors.</p>

<pre><code>Ring: R = Z‚Çë[x]/(x‚Åø + 1) where n is power of 2
Element: Polynomial a(x) = a‚ÇÄ + a‚ÇÅx + ... + a_{n-1}x^{n-1}

RLWE Instance:
  Public: a(x) ‚àà R, b(x) ‚âà a(x)¬∑s(x) + e(x)
  Secret: s(x) ‚àà R

Advantages:
  - Compact representation: n coefficients vs n¬≤ matrix
  - Fast operations: FFT-based multiplication O(n log n)
  - Same security as LWE (under additional assumptions)</code></pre>

<h4>SEAL PIR (Microsoft SEAL)</h4>

<p><strong>Architecture:</strong></p>

<pre><code>Ciphertext Packing:
  - Encode multiple plaintexts in single ciphertext using CRT
  - BFV/BGV scheme supports SIMD operations
  - Process d elements per ciphertext where d = poly(Œª)

Database Structure:
  - Partition into d √ó m matrix
  - Each cell contains d elements packed
  - Total: d¬≤ ¬∑ m elements

Query:
  - Encrypted selection vector for row
  - Size: O(d ¬∑ Œª¬≤) bits

Response:
  - Homomorphic inner product
  - Size: O(m ¬∑ Œª¬≤) bits

Setting d ‚âà m ‚âà n^(1/4):
  Communication: O(n^(1/4) ¬∑ Œª¬≤) bits</code></pre>

<h2 id="pir-schemes">3. PIR Schemes</h2>

<h3>3.1 Multi-Server Information-Theoretic PIR</h3>

<h4>Architecture</h4>

<p><strong>System Setup:</strong></p>

<pre><code>Components:
  - k ‚â• 2 non-colluding servers
  - Database D replicated identically on all servers
  - Client with no persistent state

Non-Collusion Model:
  - Servers do not communicate during protocol
  - Can be enforced via:
    * Separate administrative domains
    * Geographic distribution
    * Legal/contractual agreements
    * Reputation systems</code></pre>

<h4>IT-PIR Protocol Template</h4>

<pre><code>Query Generation (Client):
  1. Generate k correlated queries (Q‚ÇÅ, ..., Q_k)
  2. Property: Each Q‚±º individually reveals nothing
  3. Property: Combined, queries encode index i

Query Distribution:
  Send Q‚±º to Server j

Server Computation:
  Server j receives Q‚±º
  Computes response R‚±º = f(D, Q‚±º)
  Returns R‚±º to client

Client Recovery:
  Combine responses: x·µ¢ = g(R‚ÇÅ, ..., R_k)
  Extract desired element</code></pre>

<h4>Concrete Example: Three-Server PIR</h4>

<pre><code>Database: n = 27 elements, arranged as 3√ó3√ó3 cube
Query: Element at position (i‚ÇÅ, i‚ÇÇ, i‚ÇÉ)

Query Construction:
  Generate random planes:
    P‚ÇÅ: Random 3√ó3 matrix except row i‚ÇÅ
    P‚ÇÇ: Random 3√ó3 matrix except column i‚ÇÇ
    P‚ÇÉ: Random 3√ó3 matrix except position (i‚ÇÅ, i‚ÇÇ)

  Encode target position in differences

Server Computation:
  Each server computes weighted sum along one dimension
  Returns 9 values (one 3√ó3 plane)

Client Recovery:
  Combine three planes using multilinear algebra
  Extract x·µ¢ = x_{i‚ÇÅ,i‚ÇÇ,i‚ÇÉ}

Communication: O(‚àõn) = O(9) values per server</code></pre>

<h4>Communication Lower Bounds</h4>

<p><strong>Theoretical Results:</strong></p>

<pre><code>Single-Server IT-PIR:
  Theorem: Requires Œ©(n) communication
  Proof: Server must send ‚â• n bits to ensure correctness
  Conclusion: Single-server IT-PIR is impossible

k-Server IT-PIR:
  Lower bound: Œ©(n^(1/k)) communication

  Matching upper bound: O(k ¬∑ n^(1/(2k-1)))

  Optimal known: O(n^(1/k)) achievable for k = 2,3</code></pre>

<h3>3.2 Lattice-Based Computational PIR</h3>

<h4>OnionPIR Architecture</h4>

<p><strong>Innovation:</strong> Response-efficient PIR using onion encoding.</p>

<pre><code>Database Preprocessing:
  Encode database D into layers L‚ÇÅ, ..., L_log(n)
  Layer structure allows efficient extraction

Query Structure:
  Encrypted path through layers
  Each layer-query is LWE ciphertext

Server Computation:
  Process query layer by layer
  Homomorphically select path
  Final layer contains encrypted element

Response:
  Single ciphertext per query
  Size: O(Œª¬≤) bits (independent of n, ‚Ñì!)

Communication Breakdown:
  Query: O(log n ¬∑ Œª¬≤) bits
  Response: O(Œª¬≤) bits
  Total: O(log n ¬∑ Œª¬≤) bits for ‚Ñì-bit element

Advantage over basic lattice PIR:
  Response size independent of element size ‚Ñì
  Crucial for large elements (genomic sequences)</code></pre>

<h4>SimplePIR</h4>

<p><strong>Goal:</strong> Minimize server computation while maintaining good communication.</p>

<pre><code>Key Ideas:
  1. Hybrid approach: IT-PIR structure with LWE encryption
  2. Minimize homomorphic operations
  3. Optimize for modern CPUs (SIMD, parallelization)

Database Representation:
  D organized as matrix: ‚àön √ó ‚àön
  Each entry: ‚Ñì bits

Query:
  Two encrypted selection vectors
    Q_row: Encrypts row index
    Q_col: Encrypts column index
  Size: O(‚àön ¬∑ Œª) bits each

Server Computation:
  Phase 1: Select row using Q_row
    - Simple linear combination (fast!)
    - Output: encrypted row

  Phase 2: Select element from row using Q_col
    - Another linear combination
    - Output: encrypted element

  Computation: O(n) simple operations (vs. expensive HE ops)

Performance (n = 2¬≤‚Å∞, ‚Ñì = 288 bits):
  Query: 64 KB
  Response: 6 KB
  Server time: 34 ms
  Throughput: ~30 queries/sec on single core</code></pre>

<h3>3.3 Homomorphic Encryption PIR</h3>

<h4>Paillier-Based PIR</h4>

<p><strong>Paillier Cryptosystem:</strong></p>

<pre><code>Key Generation:
  Select primes p, q
  N = p ¬∑ q
  Œª = lcm(p-1, q-1)
  g = N + 1 (simplified)
  Public key: (N, g)
  Private key: Œª

Encryption of m ‚àà Z_N:
  Select random r ‚àà Z_N*
  c = g^m ¬∑ r^N mod N¬≤

Homomorphic Property:
  Enc(m‚ÇÅ) ¬∑ Enc(m‚ÇÇ) = Enc(m‚ÇÅ + m‚ÇÇ) mod N
  Enc(m)^k = Enc(k ¬∑ m)

Decryption:
  m = L(c^Œª mod N¬≤) / L(g^Œª mod N¬≤) mod N
  where L(x) = (x-1)/N</code></pre>

<p><strong>Paillier PIR Protocol:</strong></p>

<pre><code>Query Construction:
  Indicator vector q = (0, ..., 1, ..., 0)
  Encrypt: Q = (Enc(q‚ÇÅ), ..., Enc(q‚Çô))

Server Computation:
  Compute: R = ‚àè‚±º‚Çå‚ÇÅ‚Åø Q‚±º^{x‚±º}
         = ‚àè‚±º‚Çå‚ÇÅ‚Åø Enc(q‚±º)^{x‚±º}
         = Enc(Œ£‚±º q‚±º ¬∑ x‚±º)
         = Enc(x·µ¢)

Communication:
  Query: O(n ¬∑ |N|¬≤) bits (large!)
  Response: O(|N|¬≤) bits

Optimization:
  Use additive secret sharing to reduce query size
  Batch multiple queries</code></pre>

<h4>FHE-Based PIR</h4>

<p><strong>Fully Homomorphic Encryption (FHE) Capability:</strong></p>

<pre><code>For any circuit C:
  FHE.Eval(C, Enc(x)) = Enc(C(x))

PIR Application:
  Circuit C_i(D): "Select element i from D"
  Query: Enc(i) under FHE
  Server: Evaluate C_i homomorphically
  Response: Enc(x·µ¢)</code></pre>

<p><strong>Challenges:</strong></p>

<ul>
  <li>High computational cost: Bootstrapping required for deep circuits</li>
  <li>Large ciphertexts: Typically MB-sized</li>
  <li>Deep circuits: Selection circuit has depth O(log n)</li>
</ul>

<p><strong>State-of-the-Art (BFV/BGV schemes):</strong></p>

<pre><code>SEAL Library Implementation:
  Security: 128-bit
  Database: n = 2¬≤‚Å∞
  Element size: 288 bits

  Query size: ~100 KB
  Response size: ~4 KB
  Server time: ~200 ms

Improvement over naive FHE:
  Use SIMD packing (CRT slots)
  Process multiple elements per ciphertext
  Amortized cost per query decreases</code></pre>

<h3>3.4 Preprocessing PIR</h3>

<h4>Concept</h4>

<p><strong>Two-Phase Approach:</strong></p>

<pre><code>Offline Phase (One-time or infrequent):
  Server preprocesses database
  Client receives hints H
  Cost: O(n) computation, O(‚àön) storage per client

Online Phase (Per query):
  Client uses hints to construct small query
  Server responds using preprocessed structure
  Cost: O(‚àön) communication</code></pre>

<h4>Concrete Construction</h4>

<pre><code>Offline Phase:
  Database D arranged as ‚àön √ó ‚àön matrix M

  Server generates puncturable PRF keys K‚ÇÅ, ..., K_{‚àön}
  For each row i:
    Encrypts row i under key K·µ¢

  Client receives:
    - Row encryptions
    - Commitment to keys

Online Query for element (i, j):
  Client requests: "Puncture key K·µ¢ at position j"

  Server returns:
    - Punctured key K'·µ¢ (reveals all except position j)

  Client:
    - Decrypts entire row except position j
    - Already has position j from offline phase

  Communication: O(‚àön ¬∑ log n) bits</code></pre>

<h4>Stateful PIR</h4>

<p><strong>Allow client state:</strong> Can achieve O(log¬≤ n) amortized communication over many queries.</p>

<pre><code>Idea: Client caches parts of database across queries
Structure: Oblivious RAM (ORAM) techniques
Trade-off: Client storage vs. communication</code></pre>

<h2 id="security-analysis">4. Security Analysis</h2>

<h3>4.1 Information Leakage Bounds</h3>

<h4>Information-Theoretic PIR</h4>

<p><strong>Perfect Privacy:</strong></p>

<pre><code>Mutual Information:
  I(i ; ServerView_j) = 0 for all servers j

Entropy:
  H(i | ServerView_j) = H(i) = log n bits

Consequence:
  No computation can extract information about i
  Privacy holds even against quantum adversaries</code></pre>

<h4>Computational PIR</h4>

<p><strong>Privacy Parameter:</strong></p>

<pre><code>Security Parameter: Œª (typically 128 or 256)

Distinguishing Advantage:
  For any PPT adversary A:
    Adv_A = |P(A(Query_i) = 1) - P(A(Query_j) = 1)|
          ‚â§ 2^{-Œª} + negl(Œª)

Concrete Security:
  Œª = 128: Adversary must perform ~2¬π¬≤‚Å∏ operations
  Œª = 256: Post-quantum security level</code></pre>

<h4>Side-Channel Leakage</h4>

<p><strong>Timing Attacks:</strong></p>

<pre><code>Risk: Server computation time may depend on query
Mitigation: Constant-time implementations
  - Ensure all branches take same time
  - Avoid data-dependent memory access patterns

Analysis:
  Measure time variance across different queries
  Should be negligible (< 0.1% variation)</code></pre>

<p><strong>Network Analysis:</strong></p>

<pre><code>Risk: Query size or response size leaks information
Mitigation: Pad to fixed sizes

Example:
  Variable-length elements x‚ÇÅ,...,x‚Çô
  Problem: Response size reveals |x·µ¢|
  Solution: Pad all elements to max length</code></pre>

<h3>4.2 Communication Overhead</h3>

<h4>Asymptotic Comparison</h4>

<table>
  <thead>
    <tr>
      <th>Scheme</th>
      <th>Type</th>
      <th>Query Size</th>
      <th>Response Size</th>
      <th>Total</th>
      <th>Servers</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Trivial (download all)</td>
      <td>IT</td>
      <td>O(log n)</td>
      <td>O(n¬∑‚Ñì)</td>
      <td>O(n¬∑‚Ñì)</td>
      <td>1</td>
    </tr>
    <tr>
      <td>Two-server IT-PIR</td>
      <td>IT</td>
      <td>O(‚àön)</td>
      <td>O(‚àön¬∑‚Ñì)</td>
      <td>O(‚àön¬∑‚Ñì)</td>
      <td>2</td>
    </tr>
    <tr>
      <td>k-server IT-PIR</td>
      <td>IT</td>
      <td>O(k¬∑n^{1/k})</td>
      <td>O(k¬∑n^{1/k}¬∑‚Ñì)</td>
      <td>O(k¬∑n^{1/k}¬∑‚Ñì)</td>
      <td>k</td>
    </tr>
    <tr>
      <td>Basic LWE PIR</td>
      <td>Comp</td>
      <td>O(n¬∑Œª¬≤)</td>
      <td>O(‚Ñì¬∑Œª¬≤)</td>
      <td>O(n¬∑Œª¬≤)</td>
      <td>1</td>
    </tr>
    <tr>
      <td>Recursive LWE PIR</td>
      <td>Comp</td>
      <td>O(‚àön¬∑Œª¬≤)</td>
      <td>O(‚àön¬∑‚Ñì)</td>
      <td>O(‚àön¬∑(Œª¬≤+‚Ñì))</td>
      <td>1</td>
    </tr>
    <tr>
      <td>SEAL PIR</td>
      <td>Comp</td>
      <td>O(n^{1/4}¬∑Œª¬≤)</td>
      <td>O(n^{1/4}¬∑Œª¬≤)</td>
      <td>O(n^{1/4}¬∑Œª¬≤)</td>
      <td>1</td>
    </tr>
    <tr>
      <td>OnionPIR</td>
      <td>Comp</td>
      <td>O(log n¬∑Œª¬≤)</td>
      <td>O(Œª¬≤)</td>
      <td>O(log n¬∑Œª¬≤)</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<h4>Concrete Measurements</h4>

<p><strong>Scenario:</strong> Database with n = 2¬≤‚Å∞ elements, each ‚Ñì = 288 bits.</p>

<table>
  <thead>
    <tr>
      <th>Scheme</th>
      <th>Query (KB)</th>
      <th>Response (KB)</th>
      <th>Total (KB)</th>
      <th>Savings vs. Trivial</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Download all</td>
      <td>0.01</td>
      <td>37,748</td>
      <td>37,748</td>
      <td>1√ó</td>
    </tr>
    <tr>
      <td>Two-server IT-PIR</td>
      <td>4</td>
      <td>37</td>
      <td>41</td>
      <td>920√ó</td>
    </tr>
    <tr>
      <td>SimplePIR</td>
      <td>64</td>
      <td>6</td>
      <td>70</td>
      <td>539√ó</td>
    </tr>
    <tr>
      <td>SEAL PIR</td>
      <td>102</td>
      <td>4</td>
      <td>106</td>
      <td>356√ó</td>
    </tr>
    <tr>
      <td>OnionPIR</td>
      <td>140</td>
      <td>0.5</td>
      <td>140.5</td>
      <td>269√ó</td>
    </tr>
  </tbody>
</table>

<h3>4.3 Server Computation Overhead</h3>

<h4>Computational Complexity</h4>

<table>
  <thead>
    <tr>
      <th>Scheme</th>
      <th>Operations</th>
      <th>Complexity</th>
      <th>Parallelizable</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>IT-PIR</td>
      <td>Field additions/mults</td>
      <td>O(n)</td>
      <td>‚úÖ Fully</td>
    </tr>
    <tr>
      <td>LWE PIR</td>
      <td>Matrix-vector products</td>
      <td>O(n¬∑Œª)</td>
      <td>‚úÖ Fully</td>
    </tr>
    <tr>
      <td>SEAL PIR</td>
      <td>Polynomial mults (NTT)</td>
      <td>O(n log Œª)</td>
      <td>‚úÖ Fully</td>
    </tr>
    <tr>
      <td>Paillier PIR</td>
      <td>Modular exponentiations</td>
      <td>O(n)</td>
      <td>‚úÖ Fully</td>
    </tr>
    <tr>
      <td>FHE PIR</td>
      <td>Bootstrapping</td>
      <td>O(n log¬≤ Œª)</td>
      <td>‚ö†Ô∏è Limited</td>
    </tr>
  </tbody>
</table>

<h4>Wall-Clock Performance</h4>

<p><strong>Single-core latency per query (n = 2¬≤‚Å∞, ‚Ñì = 288 bits):</strong></p>

<pre><code>Two-server IT-PIR:         2 ms
SimplePIR:                34 ms
SEAL PIR:                189 ms
OnionPIR:                 78 ms
Paillier PIR:          5,340 ms
FHE PIR:              45,000 ms

Throughput (queries/sec, 32 cores):
Two-server IT-PIR:     16,000
SimplePIR:                960
SEAL PIR:                 170
OnionPIR:                 410</code></pre>

<h4>Memory Requirements</h4>

<pre><code>IT-PIR:
  Server: O(n¬∑‚Ñì) for database only
  Client: O(1) working memory

Computational PIR:
  Server: O(n¬∑‚Ñì) database + O(Œª¬≤) working memory
  Client: O(Œª¬≤) for cryptographic operations

Preprocessing PIR:
  Server: O(n¬∑‚Ñì) database + O(n) preprocessed data
  Client: O(‚àön¬∑‚Ñì) cached hints</code></pre>

<h2 id="implementation">5. Implementation</h2>

<h3>5.1 Query Construction</h3>

<h4>IT-PIR Query Generation (Python-like pseudocode)</h4>

<pre><code>import secrets
from typing import List, Tuple

class ITPIRClient:
    def __init__(self, n: int, field_size: int):
        self.n = n              # Database size
        self.p = field_size     # Field modulus

    def generate_two_server_query(self, index: int) -> Tuple[List[int], List[int]]:
        """Generate correlated queries for two-server PIR."""
        # Generate random vector for Server 2
        r = [secrets.randbelow(self.p) for _ in range(self.n)]

        # Construct query for Server 1 (differs at index)
        q = r.copy()
        q[index] = (q[index] + 1) % self.p

        return q, r

    def recover_element(self, response1: int, response2: int) -> int:
        """Recover element from server responses."""
        return (response1 - response2) % self.p</code></pre>

<h4>Lattice PIR Query Construction</h4>

<pre><code>import numpy as np

class LWEPIRClient:
    def __init__(self, n: int, dimension: int, modulus: int):
        self.n = n              # Database size
        self.d = dimension      # LWE dimension
        self.q = modulus        # LWE modulus
        self.generate_keys()

    def generate_keys(self):
        """Generate LWE key pair."""
        # Secret key: small random vector
        self.sk = np.random.randint(-2, 3, size=self.d)

        # Public key: (A, b = As + e)
        self.A = np.random.randint(0, self.q, size=(self.n, self.d))
        e = np.random.randint(-2, 3, size=self.n)
        self.b = (self.A @ self.sk + e) % self.q

    def encrypt(self, msg: int) -> Tuple[np.ndarray, int]:
        """LWE encryption of message."""
        r = np.random.randint(0, 2, size=self.n)
        u = (self.A.T @ r) % self.q
        v = (self.b @ r + msg * (self.q // 2)) % self.q
        return u, v

    def generate_query(self, index: int) -> List[Tuple]:
        """Generate encrypted indicator vector."""
        query = []
        for i in range(self.n):
            msg = 1 if i == index else 0
            query.append(self.encrypt(msg))
        return query

    def decrypt(self, u: np.ndarray, v: int) -> int:
        """LWE decryption."""
        noisy = (v - np.dot(self.sk, u)) % self.q
        # Round to nearest {0, q/2}
        return 1 if noisy > self.q // 4 and noisy < 3 * self.q // 4 else 0</code></pre>

<h3>5.2 Server Response Computation</h3>

<h4>IT-PIR Server (Optimized)</h4>

<pre><code>class ITPIRServer:
    def __init__(self, database: List[int], field_size: int):
        self.D = database
        self.p = field_size
        self.n = len(database)

    def process_query(self, query: List[int]) -> int:
        """Compute inner product of query and database."""
        # Optimized: vectorized computation
        result = 0
        for i in range(self.n):
            result = (result + query[i] * self.D[i]) % self.p
        return result

    def process_query_parallel(self, query: List[int], num_workers: int = 8) -> int:
        """Parallel processing for large databases."""
        from multiprocessing import Pool

        chunk_size = self.n // num_workers
        chunks = []

        for i in range(num_workers):
            start = i * chunk_size
            end = start + chunk_size if i < num_workers - 1 else self.n
            chunks.append((query[start:end], self.D[start:end]))

        with Pool(num_workers) as pool:
            partial_results = pool.starmap(self._compute_chunk, chunks)

        return sum(partial_results) % self.p

    @staticmethod
    def _compute_chunk(query_chunk: List[int], data_chunk: List[int]) -> int:
        """Compute partial inner product."""
        return sum(q * d for q, d in zip(query_chunk, data_chunk))</code></pre>

<h4>Lattice PIR Server</h4>

<pre><code>class LWEPIRServer:
    def __init__(self, database: List[bytes]):
        self.D = database
        self.n = len(database)

    def process_query(self, query: List[Tuple[np.ndarray, int]]) -> List[Tuple[np.ndarray, int]]:
        """Process encrypted query homomorphically."""
        # Database elements as bit vectors
        ‚Ñì = len(self.D[0]) * 8  # Element size in bits

        responses = []
        for bit_pos in range(‚Ñì):
            # Extract bit_pos from all elements
            bits = [(int.from_bytes(self.D[j], 'big') >> bit_pos) & 1
                    for j in range(self.n)]

            # Homomorphic linear combination
            u_sum = np.zeros_like(query[0][0])
            v_sum = 0

            for j in range(self.n):
                if bits[j] == 1:
                    u_j, v_j = query[j]
                    u_sum = (u_sum + u_j) % self.q
                    v_sum = (v_sum + v_j) % self.q

            responses.append((u_sum, v_sum))

        return responses</code></pre>

<h3>5.3 Answer Extraction and Verification</h3>

<h4>Client-Side Recovery</h4>

<pre><code>class PIRClient:
    """Unified PIR client interface."""

    def recover_it_pir(self, responses: List[int]) -> int:
        """Recover element from IT-PIR responses."""
        # For two servers
        return (responses[0] - responses[1]) % self.p

    def recover_lattice_pir(self, responses: List[Tuple]) -> bytes:
        """Recover element from lattice PIR responses."""
        bits = []
        for u, v in responses:
            bit = self.lwe_client.decrypt(u, v)
            bits.append(bit)

        # Reconstruct bytes from bits
        result = 0
        for i, bit in enumerate(bits):
            result |= (bit << i)

        return result.to_bytes(len(bits) // 8, 'big')

    def verify_response(self, element: bytes, expected_hash: bytes) -> bool:
        """Verify retrieved element (if commitment available)."""
        import hashlib
        computed_hash = hashlib.sha256(element).digest()
        return computed_hash == expected_hash</code></pre>

<h3>5.4 Optimization Techniques</h3>

<h4>Database Preprocessing</h4>

<pre><code>class OptimizedPIRServer:
    """PIR server with preprocessing for better cache locality."""

    def __init__(self, database: List[bytes]):
        self.n = len(database)
        self.‚Ñì = len(database[0]) * 8

        # Transpose database for bit-sliced access
        self.D_transposed = self._transpose_to_bit_slices(database)

    def _transpose_to_bit_slices(self, database: List[bytes]) -> np.ndarray:
        """Convert database to bit-sliced representation."""
        # Shape: (‚Ñì, n) where ‚Ñì = bits per element
        bit_matrix = np.zeros((self.‚Ñì, self.n), dtype=np.uint8)

        for i, element in enumerate(database):
            value = int.from_bytes(element, 'big')
            for bit_pos in range(self.‚Ñì):
                bit_matrix[bit_pos, i] = (value >> bit_pos) & 1

        return bit_matrix

    def process_query_optimized(self, query: np.ndarray) -> np.ndarray:
        """Process using bit-sliced database (vectorized)."""
        # Matrix-vector products: much faster with NumPy
        responses = self.D_transposed @ query
        return responses</code></pre>

<h4>Batch Query Processing</h4>

<pre><code>class BatchPIRServer:
    """Handle multiple queries efficiently."""

    def process_batch(self, queries: List[np.ndarray]) -> List[np.ndarray]:
        """Process multiple queries in parallel."""
        batch_size = len(queries)

        # Stack queries into matrix: (n, batch_size)
        Q = np.column_stack(queries)

        # Single matrix multiplication: D^T @ Q
        # Shape: (‚Ñì, n) @ (n, batch_size) = (‚Ñì, batch_size)
        responses = self.D_transposed @ Q

        # Split back into individual responses
        return [responses[:, i] for i in range(batch_size)]

    def amortized_communication(self, batch_size: int) -> dict:
        """Calculate amortized costs for batch queries."""
        # With ciphertext packing, can process multiple queries
        # in space of single query
        packed_queries = (batch_size + self.pack_factor - 1) // self.pack_factor

        return {
            'total_query_size': packed_queries * self.query_size,
            'total_response_size': packed_queries * self.response_size,
            'amortized_per_query': (packed_queries * self.query_size) / batch_size
        }</code></pre>

<h3>5.5 Performance Benchmarks</h3>

<h4>Measurement Framework</h4>

<pre><code>import time
from dataclasses import dataclass

@dataclass
class PIRMetrics:
    query_time: float          # Client query generation (ms)
    query_size: int            # Query size (bytes)
    server_time: float         # Server processing (ms)
    response_size: int         # Response size (bytes)
    recovery_time: float       # Client recovery (ms)
    total_time: float          # End-to-end (ms)
    communication: int         # Total bytes transferred

def benchmark_pir(scheme, n: int, element_size: int, num_trials: int = 100):
    """Comprehensive PIR benchmarking."""
    metrics_list = []

    for trial in range(num_trials):
        # Random query index
        index = secrets.randbelow(n)

        # Query generation
        t0 = time.perf_counter()
        query = scheme.client.generate_query(index)
        t1 = time.perf_counter()
        query_time = (t1 - t0) * 1000
        query_size = len(serialize(query))

        # Server processing
        t2 = time.perf_counter()
        response = scheme.server.process_query(query)
        t3 = time.perf_counter()
        server_time = (t3 - t2) * 1000
        response_size = len(serialize(response))

        # Client recovery
        t4 = time.perf_counter()
        element = scheme.client.recover(response)
        t5 = time.perf_counter()
        recovery_time = (t5 - t4) * 1000

        metrics_list.append(PIRMetrics(
            query_time=query_time,
            query_size=query_size,
            server_time=server_time,
            response_size=response_size,
            recovery_time=recovery_time,
            total_time=query_time + server_time + recovery_time,
            communication=query_size + response_size
        ))

    return aggregate_metrics(metrics_list)</code></pre>

<h2 id="applications">6. Applications</h2>

<h3>6.1 Genomic Database Queries</h3>

<h4>Problem Context</h4>

<p><strong>Scenario:</strong> Patient wants to check if their genome contains specific disease-associated variants from a medical database.</p>

<p><strong>Privacy Requirements:</strong></p>
<ul>
  <li>Database should not learn which variants patient is checking</li>
  <li>Reveals sensitive health information (Huntington's, BRCA mutations, etc.)</li>
  <li>Regulatory compliance: HIPAA, GDPR</li>
</ul>

<h4>GenomeVault PIR Integration</h4>

<pre><code>Architecture:
  Database: 10‚Å∂ genetic variants, each 36 bytes
    - Variant ID (12 bytes)
    - Genomic position (8 bytes)
    - Associated metadata (16 bytes)

  Deployment: Two-server IT-PIR
    - Server 1: Medical institution A
    - Server 2: Medical institution B
    - Legal non-collusion agreement

  Protocol:
    1. Patient identifies variants to check (indices i‚ÇÅ, ..., i_k)
    2. Generate k independent PIR queries
    3. Submit to both servers
    4. Recover variant data privately

Performance:
  Query time: 12 ms per variant
  Communication: 4 KB per variant
  Server throughput: 8,000 queries/sec per server

  Batch optimization:
    100 variants: 380 KB total (vs. 37 MB download all)
    Savings: 97.4%</code></pre>

<h4>Extended Application: Polygenic Risk Scores</h4>

<pre><code>Problem: Calculate polygenic risk score (PRS) from SNP database
  PRS = Œ£·µ¢ Œ≤·µ¢ ¬∑ g·µ¢
  where Œ≤·µ¢ = effect size, g·µ¢ = genotype at SNP i

Private Computation:
  1. Use PIR to retrieve relevant Œ≤·µ¢ values
  2. Client computes PRS locally using own genotype
  3. Database learns nothing about which SNPs patient carries

Example:
  PRS for coronary artery disease
  ~1M SNPs, need ~100K with non-zero Œ≤
  PIR retrieval: 390 MB vs. 12 GB full download
  Time: ~5 minutes vs. hours</code></pre>

<h3>6.2 Private Search</h3>

<h4>Search Engine Privacy</h4>

<p><strong>Standard Search:</strong></p>
<pre><code>User ‚Üí "query terms" ‚Üí Search Engine
Problem: Search engine learns all queries
Concerns: Profiling, tracking, data collection</code></pre>

<p><strong>PIR-Based Private Search:</strong></p>

<pre><code>Architecture:
  Inverted Index: term ‚Üí list of document IDs
    Database: n = 10‚Åπ terms

  Protocol:
    1. Hash query terms to indices
    2. Use PIR to retrieve posting lists
    3. Client-side ranking and intersection

Challenges:
  - Large posting lists (variable size)
  - Need multiple PIR queries (AND/OR queries)
  - Ranking requires document metadata

Solution: Hybrid approach
  - PIR for initial retrieval
  - Oblivious RAM for document fetching
  - Differential privacy for ranking signals</code></pre>

<h4>Keyword PIR Optimizations</h4>

<pre><code>Frequency-Based Partitioning:
  Partition database by term frequency
    Tier 1: Common terms (top 10K) - small PIR overhead
    Tier 2: Medium terms (10K-1M) - standard PIR
    Tier 3: Rare terms (>1M) - download entire tier

  Query "machine learning":
    "machine": Tier 1 - PIR cost: 100 KB
    "learning": Tier 1 - PIR cost: 100 KB
    Total: 200 KB vs. full index: 500 GB</code></pre>

<h3>6.3 Certificate Transparency and Revocation</h3>

<h4>Problem</h4>

<p><strong>Certificate Revocation Lists (CRL):</strong></p>
<ul>
  <li>Browsers need to check if certificates are revoked</li>
  <li>Standard: Download entire CRL (~10-50 MB)</li>
  <li>Privacy issue: Server learns which sites you visit</li>
</ul>

<h4>PIR for OCSP</h4>

<pre><code>Online Certificate Status Protocol (OCSP):
  Database: n = 10‚Å∏ certificates
  Element: Revocation status (1 bit) + timestamp (32 bits)

PIR Protocol:
  Query: Certificate serial number hashed to index
  Response: Status + proof

  Communication:
    SEAL PIR: 150 KB query + 5 KB response
    vs.
    Full CRL download: 15 MB

  Savings: 99% reduction

Privacy Guarantee:
  Certificate Authority (CA) learns nothing about which cert
  User privacy preserved during revocation check</code></pre>

<h4>Certificate Transparency Logs</h4>

<pre><code>Application: Monitor CT logs for unauthorized certificates

Problem:
  CT logs: 10‚Åπ+ certificates
  Need to check if your domains appear
  Don't want to reveal which domains you own

PIR Solution:
  Index CT logs by domain hash
  Periodic PIR queries to check for new entries
  Alert if unauthorized certificate detected

Performance:
  1,000 domains monitored
  Daily check: 1,000 PIR queries
  Communication: ~100 MB/day
  vs.
  Full CT log download: 5 TB/day</code></pre>

<h3>6.4 Location-Based Services</h3>

<h4>Private Proximity Queries</h4>

<p><strong>Problem:</strong> Find nearby restaurants/services without revealing location.</p>

<pre><code>Standard Approach:
  Client ‚Üí (latitude, longitude) ‚Üí Service
  Problem: Service learns exact location

PIR Approach:
  Grid-based encoding:
    Divide region into grid cells
    Database: Points of interest per cell

  Protocol:
    1. Determine grid cell from GPS coordinates
    2. PIR query for adjacent cells (3√ó3 = 9 cells)
    3. Client filters results locally

Privacy-Utility Trade-off:
  Fine grid: Better utility, higher PIR cost
  Coarse grid: Lower cost, less precise results

Example: City-scale (10km √ó 10km, 100m cells):
  Database size: n = 10,000 cells
  PIR query: 9 queries
  Communication: ~1 MB vs. sending exact coordinates</code></pre>

<h4>Private Route Planning</h4>

<pre><code>Oblivious Map Queries:
  Problem: Route planning reveals start/end locations

  Approach:
    1. Partition map into regions
    2. PIR queries for relevant map tiles
    3. Client-side routing (Dijkstra, A*)

  Optimization:
    Hierarchical maps: coarse-to-fine PIR
    Cache common routes
    Prefetch likely next regions</code></pre>

<h3>6.5 Secure Multi-Party Computation Integration</h3>

<h4>Private Input Selection for MPC</h4>

<p><strong>Scenario:</strong> Multiple parties want to compute function on private database elements without revealing selections.</p>

<pre><code>Protocol:
  Parties: P‚ÇÅ, ..., P_m
  Database: Shared among parties

  Phase 1: Private Input Selection
    Each party P‚±º uses PIR to select input x·µ¢‚±º
    Database servers learn nothing about indices

  Phase 2: MPC on Selected Inputs
    Parties run MPC protocol on {x·µ¢‚ÇÅ, ..., x·µ¢‚Çò}
    Compute f(x·µ¢‚ÇÅ, ..., x·µ¢‚Çò) without revealing inputs

Example: Private Set Intersection with Private Selection
  Party 1: Has set S‚ÇÅ, wants to check elements at indices I‚ÇÅ
  Party 2: Has set S‚ÇÇ, wants to check elements at indices I‚ÇÇ

  Goal: Compute |S‚ÇÅ[I‚ÇÅ] ‚à© S‚ÇÇ[I‚ÇÇ]| without revealing I‚ÇÅ, I‚ÇÇ

  Solution:
    1. PIR to select S‚ÇÅ[I‚ÇÅ] and S‚ÇÇ[I‚ÇÇ]
    2. PSI protocol on selected elements</code></pre>

<h4>PIR-Assisted Private Database Joins</h4>

<pre><code>Problem: Join two private databases on shared key

Setup:
  Database A: n_A records (key, value_A)
  Database B: n_B records (key, value_B)
  Goal: For matching keys, compute f(value_A, value_B)

Protocol:
  1. Party A holds keys K_A
  2. For each k ‚àà K_A:
     a. Use PIR to check if k ‚àà B
     b. If yes, retrieve value_B[k]
  3. Locally compute f(value_A[k], value_B[k])

Privacy:
  - Database B learns nothing about which keys A queried
  - A learns only values for keys it already has

Communication:
  PIR per key: O(‚àön_B)
  Total: O(|K_A| ¬∑ ‚àön_B)
  vs.
  Revealing join keys: O(|K_A| ¬∑ log n_B)</code></pre>

<h3>6.6 Private Machine Learning</h3>

<h4>Private Model Queries</h4>

<p><strong>Scenario:</strong> Query ML model predictions without revealing input features.</p>

<pre><code>Model Database:
  Precomputed predictions for discretized input space
  Example: Image classification - 256¬≥ possible RGB centroids

PIR Protocol:
  1. Discretize input (nearest centroid)
  2. PIR query for prediction at discretized input
  3. Retrieve model output privately

Alternative: Private Neural Network Inference
  Combine PIR with homomorphic encryption
  PIR: Retrieve relevant model weights
  HE: Compute inference homomorphically</code></pre>

<h4>Federated Learning with PIR</h4>

<pre><code>Private Gradient Aggregation:
  Participants contribute gradients to shared model
  PIR ensures contribution source privacy

  Protocol:
    1. Each party computes gradient
    2. Uploads to gradient database with PIR-based indexing
    3. Aggregator uses PIR to selectively retrieve
    4. Prevents targeted gradient leakage attacks</code></pre>

<div class="references">
  <h2 id="references">References</h2>
  <ol>
    <li><strong>Chor, B., Goldreich, O., Kushilevitz, E., & Sudan, M.</strong> (1995). Private information retrieval. <em>Proceedings of 36th Annual Symposium on Foundations of Computer Science</em>, 41-50. [Foundational work introducing IT-PIR]</li>

    <li><strong>Kushilevitz, E., & Ostrovsky, R.</strong> (1997). Replication is not needed: Single database, computationally-private information retrieval. <em>Proceedings of 38th Annual Symposium on Foundations of Computer Science</em>, 364-373. [First single-server computational PIR]</li>

    <li><strong>Lipmaa, H.</strong> (2005). An oblivious transfer protocol with log-squared communication. <em>Information Security Conference</em>, 314-328. [Log-squared communication PIR]</li>

    <li><strong>Gentry, C., & Ramzan, Z.</strong> (2005). Single-database private information retrieval with constant communication rate. <em>ICALP</em>, 803-815. [Constant-rate PIR construction]</li>

    <li><strong>Aguilar-Melchor, C., & Gaborit, P.</strong> (2007). A lattice-based computationally-efficient private information retrieval protocol. <em>Western European Workshop on Research in Cryptology</em>. [Early lattice-based PIR]</li>

    <li><strong>Devet, C., Goldberg, I., & Heninger, N.</strong> (2012). Optimally robust private information retrieval. <em>USENIX Security Symposium</em>. [Byzantine-robust PIR]</li>

    <li><strong>Olumofin, F., & Goldberg, I.</strong> (2011). Revisiting the computational practicality of private information retrieval. <em>International Conference on Financial Cryptography and Data Security</em>. [Practical PIR implementations]</li>

    <li><strong>Angel, S., Chen, H., Laine, K., & Setty, S.</strong> (2018). PIR with compressed queries and amortized query processing. <em>IEEE Symposium on Security and Privacy</em>. [SEAL PIR - RLWE-based efficient PIR]</li>

    <li><strong>Mughees, M. H., Chen, H., & Ren, L.</strong> (2023). OnionPIR: Response efficient single-server PIR. <em>ACM CCS</em>. [State-of-the-art response-efficient PIR]</li>

    <li><strong>Henzinger, A., Lazzaretti, M. M., & Sherry, J.</strong> (2023). SimplePIR: Simple and Practical Single-Server Private Information Retrieval. <em>USENIX Security Symposium</em>. [Optimized LWE-based PIR with minimal overhead]</li>

    <li><strong>Corrigan-Gibbs, H., & Kogan, D.</strong> (2020). Private information retrieval with sublinear online time. <em>EUROCRYPT</em>. [Preprocessing PIR schemes]</li>

    <li><strong>Patel, S., Persiano, G., Yeo, K., & Yung, M.</strong> (2018). Mitigating leakage in secure cloud-hosted data structures. <em>ACM CCS</em>. [PIR for cloud storage]</li>
  </ol>
</div>

<script src="../theme-sync.js"></script>
</body>
</html>